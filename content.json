{"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"06-15","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"06-15","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-15","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"06-15","excerpt":""}],"posts":[{"title":"Nginx与tomcat组合的简单使用","text":"#Nginx与tomcat组合的简单使用文章版权由作者李晓晖和博客园共有，若转载请于明显处标明出处：http://www.cnblogs.com/naaoveGIS/ ##1.背景项目中瓦片资源越来越多，如果提高瓦片的访问效率是一个需要解决的问题。这里，我们考虑使用Nginx来代理静态资源进行初步解决。 ##2.Nginx简介ginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的。 何为反向代理呢？即以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 而Nginx主要完成的工作就是反向代理，比如我们向一台服务器的80端口发送了请求，该请求首先由Nginx监听到，其接受到请求内容后再转发给其他服务器，其他服务器处理完后再将结果传送给Nginx，最后由Nginx来统一返回给初始请求端。 Nginx最常见的使用方法就是作为静态资源伺服器，比如将CSS，JS，html，htm等文件进行缓存处理。 ##3.环境搭建 ###3.1下载 首先在官网中下载所需版本：http://nginx.org/en/download.html。目前我使用的版本是windows环境下的1.9.15。下载完毕后，解压。 ###3.2开启Nginx开启Nginx有两种方法，一种是直接点击开启，一种是命名行开启。a.点击开启：b.命名行开启：开启成功后，在资源管理中可以看到： ###3.3常见问题—启动失败出现启动失败问题，一般是端口冲突问题，比如win7下的IIS已经启动并占用了80端口。在config目录下找到nginx.conf，打开文件进行如下修改： ##4.初步使用 ###4.1用网页测试是否启动成功其中的配置为：其表示监听8010端口请求后，会首先去html文件夹下寻找index.html页面。 ###4.2详解部分参数含义listen：表示当前的代理服务器监听的端口，默认的是监听80端口。注意，如果我们配置了多个server，这个listen要配置不一样，不然就不能确定转到哪里去了。server_name：表示监听到之后需要转到哪里去，这时我们直接转到本地，这时是直接到nginx文件夹内。location：表示匹配的路径，这时配置了/表示所有请求都被匹配到这里root：里面配置了root这时表示当匹配这个请求的路径时，将会在这个文件夹内寻找相应的文件，这里对我们之后的静态文件伺服很有用。index：当没有指定主页时，默认会选择这个指定的文件，它可以有多个，并按顺序来加载，如果第一个不存在，则找第二个，依此类推。 ###4.3配置tomcat跳转通过proxy_pass配置请求转发地址。即当访问localhost的8010端口时，请求会跳转至localhost的8080端口处。修改完Nginx的配置后不需要重启Nginx，输入如下命令即可：测试如下： ##5.进一步使用 ###5.1静态文件分离配置上面我们直接试了一个小例子，让nginx进行转发，即所谓的反向代理。但实际上我们的需求不会是这样的，我们需要分文件类型来进行过滤，比如jsp直接给tomcat处理，因为nginx并不是servlet容器，没办法处理JSP，而html,js,css这些不需要处理的，直接给nginx进行缓存。 下面我们来进行一下配置，让JSP页面直接给tomcat，而html,png等一些图片和JS等直接给nginx进行缓存。 这时最主要用的还是location这个元素，并且涉及到一部分正则，但不难，具体配置如下：此时再直接输入localhost:8010，则会报404错误了。但是输localhost:8010/index.jsp，则一样可以跳转至tomcat首页中。 ###5.2 负载配置当一台服务器出现故障后，我们需要将请求自动转向另一台服务器，此种需求该如何配置呢？利用Nginx也是比较方便能够实现，具体配置如下：注意，上面还加上了一个weight属性，此属性表示各服务器被访问到的权重，weight越高访问到的几率越高。 ###5.3其他配置 ###5.4关闭Nginx","path":"2019/06/19/Nginx与tomcat组合的简单使用/","date":"06-19","excerpt":"","tags":[{"name":"Nginx与tomcat","slug":"Nginx与tomcat","permalink":"https://hcl411x.github.io/tags/Nginx与tomcat/"}]},{"title":"二叉树","text":"##搜索二叉树 12345 4 / \\ 2 7 / \\ / \\1 3 6 9 ####二叉搜索树的遍历,查找,删除和插入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253import java.util.Comparator;import java.util.jar.Pack200;/** * Created by lrkin on 2016/10/25. * * 二叉查找树的遍历,查找,删除和插入 * */public class BinarySearchTree&lt;T extends Comparable&lt;? super T&gt;&gt; &#123; /** * 节点数据结构 */ static class BinaryNode&lt;T&gt; &#123; T data; BinaryNode&lt;T&gt; left; BinaryNode&lt;T&gt; right; public BinaryNode(T data) &#123; this(data, null, null); &#125; public BinaryNode(T data, BinaryNode&lt;T&gt; left, BinaryNode&lt;T&gt; right) &#123; this.data = data; this.left = left; this.right = right; &#125; public BinaryNode() &#123; data = null; this.left = left; this.right = right; &#125; &#125; private BinaryNode&lt;T&gt; rootTree; /** * 构造一颗空的二叉查找树 */ public BinarySearchTree() &#123; rootTree = null; &#125; /** * 清空二叉查找树 */ public void clear() &#123; rootTree = null; &#125; /** * 判断是否为空 */ public boolean isEmpty() &#123; return rootTree == null; &#125; /** * 查找指定的元素,默认从根节点开始查询 */ public boolean contains(T t) &#123; return contains(t, rootTree); &#125; /** * 从某个节点开始查找元素 * * @param t * @param node * @return */ public boolean contains(T t, BinaryNode&lt;T&gt; node) &#123; if (node == null) return false; int result = t.compareTo(node.data); if (result &gt; 0) &#123; return contains(t, node.right); &#125; else if (result &lt; 0) &#123; return contains(t, node.left); &#125; else &#123; return true; &#125; &#125; /** * 查找二叉搜索树中的最小值 * * @return */ public T findMin() &#123; if (isEmpty()) &#123; System.out.println(\"二叉树为空\"); return null; &#125; else &#123; return findMin(rootTree).data; &#125; &#125; /** * 查找二叉搜索树中的最大值 * * @return */ public T findMax() &#123; if (isEmpty()) &#123; System.out.println(\"二叉树为空\"); return null; &#125; else &#123; return findMax(rootTree).data; &#125; &#125; /** * 插入元素 * * @param t */ public void insert(T t) &#123; rootTree = insert(t, rootTree); &#125; public void remove(T t) &#123; rootTree = remove(t, rootTree); &#125; /** * 删除元素,3种情况讨论(实际上是两种): * 1)此元素为叶子节点,直接删除即可(也同2),只不过是null * 2)此元素只有左子树或者右子树,那么˙直接删除该节点,该节点的左(或右)节点设置为其父节点的左(或右)节点(取决于它是本身是父节点的左还是右节点) * 3)此元素的左右节点都不空,删除策略是用它左子树的最小的节点来替换它(因为右子树的最小节点不可能有左孩子,同2),很好二次删除) * &lt;p&gt; * 在这个方法中,先递归找到t对应的node * 再分两种情况处理 * * @param t * @param node * @return */ public BinaryNode&lt;T&gt; remove(T t, BinaryNode&lt;T&gt; node) &#123; if (node == null) &#123; return node; &#125; int result = t.compareTo(node.data); if (result &gt; 0) &#123; node.right = remove(t, node.right); &#125; else if (result &lt; 0) &#123; node.left = remove(t, node.left); &#125; else if (node.left != null &amp;&amp; node.right != null) &#123; node.data = findMin(node.right).data; node.right = remove(node.data, node.right); &#125; else &#123; node = (node.left != null) ? node.left : node.right; &#125; return node; &#125; /** * 插入BinarySearchTree,也是递归,但要注意方法返回的是这一层正在用的node * * @param t * @param node * @return */ public BinaryNode&lt;T&gt; insert(T t, BinaryNode&lt;T&gt; node) &#123; if (node == null) &#123; // return new BinaryNode&lt;T&gt;(t, null, null); &#125; else &#123; int result = t.compareTo(node.data); if (result &gt; 0) &#123; node.right = insert(t, node.right); &#125; else if (result &lt; 0) &#123; node.left = insert(t, node.left); &#125; else &#123; //do notion &#125; &#125; return node; &#125; public BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; node) &#123; if (node == null) &#123; return null; &#125; else if (node.left == null) &#123; return node; &#125; else &#123; return findMin(node.left); &#125; &#125; public BinaryNode&lt;T&gt; findMax(BinaryNode&lt;T&gt; node) &#123; if (node == null) &#123; return null; &#125; else if (node.right == null) &#123; return node; &#125; else &#123; return findMax(node.right); &#125; &#125; //打印 public void print(BinaryNode&lt;T&gt; node)&#123; if (node != null)&#123; System.out.print(node.data+\"---\"); print(node.left); print(node.right); &#125; &#125; public BinaryNode&lt;Integer&gt; init() &#123; BinaryNode&lt;Integer&gt; node3 = new BinaryNode&lt;Integer&gt;(3); BinaryNode&lt;Integer&gt; node1 = new BinaryNode&lt;Integer&gt;(1); BinaryNode&lt;Integer&gt; node4 = new BinaryNode&lt;Integer&gt;(4,node3,null); BinaryNode&lt;Integer&gt; node2 = new BinaryNode&lt;Integer&gt;(2,node1,node4); BinaryNode&lt;Integer&gt; node8 = new BinaryNode&lt;Integer&gt;(8); BinaryNode&lt;Integer&gt; root = new BinaryNode&lt;Integer&gt;(6,node2,node8); return root; &#125; public void preOrder(BinaryNode node) &#123; if (node != null) &#123; System.out.print(node.data+\"---\"); preOrder(node.left); preOrder(node.right); &#125; &#125; /*简单测试*/ public static void main(String[] args) &#123; BinarySearchTree searchTree = new BinarySearchTree&lt;&gt;(); BinaryNode&lt;Integer&gt; node= searchTree.init(); searchTree.rootTree=node; searchTree.preOrder(searchTree.rootTree); System.out.println(\"\"); searchTree.print(searchTree.rootTree); System.out.println(\"\"); searchTree.remove(4); searchTree.preOrder(searchTree.rootTree); System.out.println(\"\"); searchTree.print(searchTree.rootTree); &#125;&#125; ##二叉树的前序遍历,中序遍历和后序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * Created by lrkin on 2016/10/26. */public class BinaryTreeTraversal &#123; static class Node&#123; private int data; private Node leftNode; private Node rightNode; public Node(int data, Node leftNode, Node rightNode)&#123; this.data = data; this.leftNode = leftNode; this.rightNode = rightNode; &#125; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public Node getLeftNode() &#123; return leftNode; &#125; public void setLeftNode(Node leftNode) &#123; this.leftNode = leftNode; &#125; public Node getRightNode() &#123; return rightNode; &#125; public void setRightNode(Node rightNode) &#123; this.rightNode = rightNode; &#125; &#125; public Node init() &#123;//注意必须逆序建立，先建立子节点，再逆序往上建立，因为非叶子结点会使用到下面的节点，而初始化是按顺序初始化的，不逆序建立会报错 Node J = new Node(8, null, null); Node H = new Node(4, null, null); Node G = new Node(2, null, null); Node F = new Node(7, null, J); Node E = new Node(5, H, null); Node D = new Node(1, null, G); Node C = new Node(9, F, null); Node B = new Node(3, D, E); Node A = new Node(6, B, C); return A; //返回根节点 &#125; /** * 先序遍历,就是最普通的遍历 * @param root */ public void theFirstTraversal(Node root)&#123; if (root != null)&#123; System.out.print(root.getData()); theFirstTraversal(root.getLeftNode()); theFirstTraversal(root.getRightNode()); &#125; &#125; /** * 中序遍历 * @param root */ public void theInOrderTraversal(Node root)&#123; if (root != null)&#123; theInOrderTraversal(root.getLeftNode()); System.out.print(root.getData()); theInOrderTraversal(root.getRightNode()); &#125; &#125; public void thePostOrderTraversal(Node root)&#123; if (root != null)&#123; thePostOrderTraversal(root.getLeftNode()); thePostOrderTraversal(root.getRightNode()); System.out.print(root.getData()); &#125; &#125; public static void main(String[] args) &#123; BinaryTreeTraversal tree = new BinaryTreeTraversal(); Node root = tree.init(); System.out.print(\"先序遍历\"); tree.theFirstTraversal(root); System.out.print(\"\"); System.out.print(\"中序遍历\"); tree.theInOrderTraversal(root); System.out.print(\"\"); System.out.print(\"后序遍历\"); tree.thePostOrderTraversal(root); System.out.print(\"\"); &#125;&#125;//先序遍历631254978中序遍历123456789后序遍历214538796 ##求二叉树的深度和广度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import java.util.ArrayDeque;import java.util.Queue;/** * Created by lrkin on 2016/10/26. * 求二叉树的深度和广度 */public class BinaryTreeMaxDepthWidth &#123; static class TreeNode &#123; char val; TreeNode left = null; TreeNode right = null; public TreeNode(char val) &#123; this.val = val; &#125; public TreeNode(char val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125; &#125; /** * 获取最大深度 * &lt;p&gt; * 记忆点:递归 * * @param root * @return */ public static int getMaxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; else &#123; int left = getMaxDepth(root.left); int right = getMaxDepth(root.right); return 1 + Math.max(left, right); &#125; &#125; /** * 获取最大宽度 * &lt;p&gt; * &lt;p&gt; * 记忆点:采用队列这种数据结构,来记录每一层的宽度,遍历即可 * * @param root * @return */ public static int getMaxWidth(TreeNode root) &#123; if (root == null) return 0; //获取队列 Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;TreeNode&gt;(); int maxWidth = 1; queue.add(root); //循环 while (true) &#123; int size = queue.size(); if (size == 0) &#123; break; &#125; while (size &gt; 0) &#123; //不为零,那么一直poll完这一层的所有节点为止 TreeNode node = queue.poll(); size--; if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; //每一层,都更新maxWidth;// maxWidth = Math.max(maxWidth, size);这样写错误,因为size递减 maxWidth = Math.max(maxWidth, queue.size()); &#125; return maxWidth; &#125; public static TreeNode initBinaryTree() &#123; TreeNode J = new TreeNode('a', null, null); TreeNode H = new TreeNode('b', null, null); TreeNode G = new TreeNode('c', null, null); TreeNode F = new TreeNode('d', null, J); TreeNode E = new TreeNode('e', H, null); TreeNode D = new TreeNode('g', null, G); TreeNode C = new TreeNode('w', F, null); TreeNode B = new TreeNode('h', D, E); TreeNode A = new TreeNode('z', B, C); return A; //返回根节点//// Node J = new Node(8, null, null);// Node H = new Node(4, null, null);// Node G = new Node(2, null, null);// Node F = new Node(7, null, J);// Node E = new Node(5, H, null);// Node D = new Node(1, null, G);// Node C = new Node(9, F, null);// Node B = new Node(3, D, E);// Node A = new Node(6, B, C);// return A; //返回根节点 &#125; public static void main(String[] args) &#123; TreeNode root = initBinaryTree(); System.out.println(getMaxDepth(root)); System.out.println(getMaxWidth(root)); &#125;&#125;","path":"2019/06/17/二叉树/","date":"06-17","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hcl411x.github.io/tags/数据结构与算法/"},{"name":"二叉树","slug":"二叉树","permalink":"https://hcl411x.github.io/tags/二叉树/"}]},{"title":"二分查找","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * Created by lrkin on 2016/10/23. * 二分查找 * BinarySearch * &lt;p&gt; * 思路: * 将数组分为三部分，依次是中值（所谓的中值就是数组中间位置的那个值）前，中值，中值后； * 将要查找的值和数组的中值进行比较，若小于中值则在中值前面找，若大于中值则在中值后面找，等于中值时直接返回。 * 然后依次是一个递归过程，将前半部分或者后半部分继续分解为三部分。可能描述得不是很清楚，若是不理解可以去网上找。 * 从描述上就可以看出这个算法适合用递归来实现，可以用递归的都可以用循环来实现。 * 所以我们的实现分为递归和循环两种，可以根据代码来理解算法 * * 总结: * 刚开始写这个算法有点糊涂的地方是奇偶数的处理,但是后来发现,这个问题不是问题 * 也就是说,不需要考虑数组的长度是奇还是偶,(start+end)/2得到的就是middle,前后分出的两个子数组的元素个数一不一样不重要 * 只需要有middle这个概念就行了,然后无论递归还是循环,只需要middle+1或者middle-1构造新的子数组 * 想明白这个问题(忽视奇偶数),对其他要用到二分法的算法很有帮助 * */public class BinarySearch &#123; private int rCount = 0; private int lCount = 0; /** * 递归次数获取 * * @return */ public int getrCount() &#123; return rCount; &#125; /** * 循环次数获取 * * @return */ public int getlCount() &#123; return lCount; &#125; /** * 递归实现 */ /** * 执行递归二分查找，返回第一次出现该值的位置 * @param sortedData 已排序的数组 * @param start 开始位置 * @param end 结束位置 * @param findValue 需要找的值 * @return 值在数组中的位置，从0开始。找不到返回-1 */ public int searchRecursive(int[] sortedData,int start,int end,int findValue) &#123; rCount++; if(start&lt;=end) &#123; //中间位置 int middle=(start+end)&gt;&gt;1; //相当于(start+end)/2 //中值 int middleValue=sortedData[middle]; if(findValue==middleValue) &#123; //等于中值直接返回 return middle; &#125; else if(findValue&lt;middleValue) &#123; //小于中值时在中值前面找 return searchRecursive(sortedData,start,middle-1,findValue); &#125; else &#123; //大于中值在中值后面找 return searchRecursive(sortedData,middle+1,end,findValue); &#125; &#125; else &#123; //找不到 return -1; &#125; &#125; /** * * @param sortedData * @param findValue * @return 值在数组中第一次出现的位置 */ public int searchLoop(int[] sortedData , int findValue)&#123; int start = 0; int end = sortedData.length - 1; while (start &lt;= end)&#123; lCount ++; int middle = (start + end)/2; int middleValue = sortedData[middle]; if (findValue == middleValue)&#123; return middle; &#125;else if(findValue &lt; middleValue)&#123; end = middle - 1; &#125;else if (findValue &gt; middleValue)&#123; start = middle + 1; &#125; &#125; return -1; &#125;&#125;","path":"2019/06/17/二分查找/","date":"06-17","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hcl411x.github.io/tags/数据结构与算法/"},{"name":"二分查找","slug":"二分查找","permalink":"https://hcl411x.github.io/tags/二分查找/"}]},{"title":"快速排序","text":"##复现一遍昨晚写的快速排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class QuickSortPractice &#123; public void quickSort(int[] array) &#123; _quickSort(array, 0, array.length - 1); &#125; public void _quickSort(int[] array, int start, int end) &#123; if (array == null) &#123; return; &#125; if(start&gt;=end)&#123; return; &#125; boolean flag = false; int key = array[start]; int i = start; int j = end; while (i &lt; j) &#123; if (flag) &#123; if (array[i] &gt; key) &#123; swap(array, i, j); flag = false; &#125; else &#123; i++; &#125; &#125; else &#123; if (array[j] &lt; key) &#123; swap(array, i, j); flag = true; &#125; else &#123; j--; &#125; &#125; &#125; _quickSort(array, start, j - 1); _quickSort(array, i + 1, end); &#125; public void swap(int[] array, int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; public static void main(String[] args) &#123; int[] array = &#123;14, 2, 5, 25, 33, 6&#125;; QuickSortPractest practest = new QuickSortPractest(); practest.quickSort(array); for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + \"-\"); &#125; &#125;&#125; ##partition函数 这个函数有两种写法 一种是上面那样,另一种是下面这样 1234567891011121314public int partition(int[] array , int start , int end)&#123; int key = array[start]; while(start &lt; end)&#123; if(start &lt; end &amp;&amp; array[end] &gt;= key)&#123; end--; &#125; array[start] = array[end]; if(start &lt; end &amp;&amp; array[start] &lt;= key)&#123; start++; &#125; array[end] = array[start]; &#125; return start;&#125; ##核心 快速排序的核心四个: pivot基准值,一般取最左边那个(如果最左边的数是数组中最小的,那么时间复杂度就是最大的O(n2)) partition函数,分而治之 swap函数,交换 递归,不解释","path":"2019/06/17/关于快排中的分区函数/","date":"06-17","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hcl411x.github.io/tags/数据结构与算法/"},{"name":"快速排序","slug":"快速排序","permalink":"https://hcl411x.github.io/tags/快速排序/"}]},{"title":"插入排序","text":"##思路和记忆点 ####思路: 从前两个元素开始,依次构建有序序列即对于未排序的数据,在已排序序列中从后往前扫描,找到相应位置并插入 ####记忆点: 假设第一个元素排好(i=1开始) 对排好的部分从后往前插到正确的位置(一个循环就搞定) ##复杂度 时间复杂度是:O(n2) 空间复杂度是:O(1) ??? ##代码 12345678910111213141516171819202122232425262728293031323334353637/** * Created by lrkin on 2016/10/27. */public class InsertionSort &#123; public void print(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i]+\"-\"); &#125; &#125; public void insertSort(int[] array) &#123; int temp , i ,j; for (i = 1; i &lt; array.length; i++) &#123; temp = array[i]; for (j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; temp ; j--) &#123; array[j+1] = array[j]; &#125; array[j+1] = temp; &#125; &#125; public static void main(String[] args) &#123; InsertionSort insertionSort = new InsertionSort(); int[] array = &#123;3,12,4,53,33,22&#125;; insertionSort.print(array); insertionSort.insertSort(array); System.out.println(\"\"); insertionSort.print(array); &#125;&#125;","path":"2019/06/17/插入排序/","date":"06-17","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hcl411x.github.io/tags/数据结构与算法/"},{"name":"插入排序","slug":"插入排序","permalink":"https://hcl411x.github.io/tags/插入排序/"}]},{"title":"已经有俩张限定的银行卡","text":"#已经有俩张限定的银行卡接下来也会收集更多的限定银行卡","path":"2019/06/17/已经有俩张限定的银行卡/","date":"06-17","excerpt":"","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hcl411x.github.io/tags/杂谈/"}]},{"title":"第一次建立博客","text":"#第一次建立博客这是大学期间第一次用hexo建立的博客，虽然还有很多的功能还没有完善，但基本上上可以正常使用，以后将继续更新更多的内容，该博客从建立到美化花了3天的时间，也学到很多前端和服务器知识，该博客接下来预计更新的内容：音乐播放器，留言板，视频播放器，live2d的优化","path":"2019/06/16/第一次建立博客/","date":"06-16","excerpt":"","tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://hcl411x.github.io/tags/杂谈/"}],"preview":"imgs\\blog\\2.jpg"},{"title":"适合入门的轻小说作品推荐","text":"#适合入门的轻小说作品推荐 大家平时有阅读的习惯吗？不一定要是艰深的文学名著，通俗小说也可以，比如说日本的轻小说之类的。轻小说从字面上理解就是可以轻松阅读的小说，同时会使用动漫风格绘图作为插画，其中不少的作品还会被改编为动画。 诶，平时只看动画吗？其实轻小说也很有趣的啦。没办法，就让博览群书的安利姬来给想入门的初心者推荐一些有趣的轻小说作品吧（其实你就是以前上课经常看闲书吧喂）。凉宫春日系列 「我对普通的人类没有兴趣。你们之中要是有外星人、未来人、异世界来的人、超能力者，就尽管来找我吧！以上。」 放在首位推荐的果然还得是它，《凉宫春日系列》是由日本作家谷川流创作的系列轻小说，负责小说插画的是伊东杂音。小说的各卷标题均为《凉宫春日的××》（××可用两个汉字代入）。 对于平淡无聊的日常生活无法忍受的凉宫春日创立了一个不可思议的社团——让世界变得更热闹的凉宫春日的团，通称SOS团。 同班同学阿虚、寡言读书少女长门有希、萌萌学姐朝比奈实玖瑠、神秘转校生古泉一树等人都因此被她牵扯了进来，但是阿虚以外的三人却有着凉宫春日不知道的大秘密。通俗易懂的来说就是以凉宫春日为中心的SOS团及成员的冒险故事。 2007年8月15日发售的系列第九卷小说《凉宫春日的分裂后》系列进入了长时间的停更状态，直到2011年5月25日《凉宫春日的惊愕》上下册终于千呼万唤始出来。在大家都以为谷川老贼从良后一直停更到了现在...... 《凉宫春日系列》于2006年和2009年都被改编成了动画，系列第四卷《凉宫春日的消失》也被制作为了剧场版。京阿尼负责的动画质量过硬，在当年也引发了讨论的热潮。 虽然系列小说的长时间停更使得作品讨论度远不及当年，但如果之前你没有接触过《凉宫春日系列》，或是只看过改编动画的话，在这里安利姬推荐你绝对不要错过充满谷川流天马行空想象的原作小说。奇诺之旅 「这世界并不美丽。然而，也因此美丽。」 世界上为何会有这么多不同的国家存在呢？能了解别人痛苦的国度、以多数表决所有事务的国度、12岁之后便得成为大人的国度等等……旅人奇诺与会说话的摩托车汉密斯展开周游列国的旅程，她们在每个国家必定只停留3天的时间，对在旅途中所看见的情景也不多加评判与干涉，只是静静的观察并接受，这就是小说《奇诺之旅》的故事。 从2000年第一卷出版以来，《奇诺之旅》已经走过了快20个年头，作者时雨泽惠一的写作频率也是越来越慢（喂！）。小说本身是单元剧的形式，每段故事对应一个不同国家，就算是以前没有阅读习惯的读者也很容易上手。虽然追了那么多年《奇诺之旅》安利姬也没有搞懂摩托车说话的原理啦，不过小说中最有趣的还是莫过于奇诺造访的那些奇妙国家，在看似离奇的国家和故事背后却总蕴含着深刻的寓意。小说在2003和2017年制作了两季的动画，但是因为小说和动画叙事节奏的不同，动画并没有很好地表现出原作小说的魅力，这也是安利姬推荐小说版的原因。 丹特丽安的书架「吾问汝，汝为人否？」「否，吾乃天，壶中之天。」 如果你喜欢和《奇诺之旅》一样的单元剧类型小说的话那《丹特丽安的书架》也是不容错过的一部作品。主人公修伊从曾用全领地的一半换取一本稀有书的收书狂祖父处，继承了古老的宅邸以及其所有的藏书。祖父开出的条件只有一个——要他继承“书架”。为整理遗物而造访宅邸的修伊在充斥着书本的地下室内，遇见了静静地读着书的少女——穿着漆黑的裙子、胸前挂着巨锁的少女妲丽安。她正是通往藏有禁断“幻书”的“丹特丽安的书架”的入口，储藏着恶魔智慧的门扉。什么？继承遗产一夜暴富还送一个可爱的萝莉？！我愿意干！ 本该被焚烧、丢失的古代图书馆的藏书，记录了雷击、魔物的召唤、获得恶魔的力量的秘诀等等藏有各种各样“力量”的本不该存在于世上的幻之书。一旦读过之后将会获得数之不尽的恩惠，但这将会使得世界的均衡面临崩溃的危机。本作的剧情发展就是修伊与妲丽安一同解决“幻书”所引发的问题。和《奇诺之旅》每段故事对应一个不同国家一样，《丹特丽安的书架》则是对应一本幻书。幻书的种类和能力也是各式各样，比如《等价之书》是一本教人走向期盼之富裕的辅导书。只要让对手听自己读的幻书内的字，那对方就必须拿出和幻书主人交出的物品等价的东西来交换。《模仿之书》则可以如实反映出封面所绘之人的内心，那个人过去有过什么经历？此刻正在想些什么？只要读了这本书，就能够得知她内心的一切。这些危险的书籍果然应该回收呢。 不过《丹特丽安的书架》在出版了第八卷后由于作者与出版社产生纠纷，就停止更新了。作者三云岳斗后来去写了新作《噬血狂袭》，书架的后续剧情也变为了有生之年系列。《丹特丽安的书架》在原作小说停更的同年有推出改编动画，最大的亮点就是可爱的妲丽安了。声优泽城美雪的御姐音和少年音非常具有辨识度，但是泽城太太最厉害的还是萝莉音啊，简直可爱到爆炸！awsl 魔法禁书目录「就让我用这只手，将你那无聊的幻想杀得片甲不留。」 少年，你听说过把妹之手吗？出处就是轻小说《魔法禁书目录》了。本书第一男主角上条当麻的能力「幻想杀手」拥有拥有能将任何能力无效化的效果。不过当麻经常吐槽自己的右手既没办法打倒不良少年，甚至连用来增加考试分数去把妹也不办不到。但实际上拜他的右手所赐，他总是会和一个又一个美少女相遇并且攻陷对方，这根本就是男性公敌吧喂！故事中的学园都市里学生占到了总人口的八成，“超能力开发”被列为绝大多数学生的必修课，在Level 0到Level 5的等级排名上相互竞争。上条当麻被评定为无能力者，但他的右手有着能将一切异能消除的不明力量。似乎是连同神的祝福一同抹杀的关系，他每天都过着不幸的生活。暑假的一天，在宿舍的阳台上，上条当麻遇见了一位挂在阳台栏杆上的修女。她自称禁书目录，脑海中装有十万三千册魔法书，正在从不为人所知的魔法世界逃亡。就这样，上条一脚踏进了把妹生活。 整部小说的开头大概是这样，但因为世界观过于庞大，《魔法禁书目录》连载了旧约22卷加上《新约魔法禁书目录》22卷也没把故事讲完……作者镰池和马也算是业界知名的打字机了，身兼多部轻小说坑写作并快乐着，真希望那些写到一半就坑掉的作者能多学习下他。《魔法禁书目录》曾被改编为了三季的动画，但是由于原作小说过多要素无法在动画中表现而删减掉了很多内容。而且因为动画制作时间跨度太大的关系已经完全追不上小说的剧情了，动画化的旧约部分说实话观感不是很好，所以还是强烈推荐直接阅读原作小说。但如果你之前没怎么接触过轻小说并对阅读大量文字有些抵触的话，《魔法禁书目录》并不是特别好的选择，因为大量的设定文字可能就会让人看得脑子爆炸……想体验庞大世界观以及各种精彩战斗并且不反感各种设定解说，那魔禁绝对是不容错过的作品。","path":"2019/06/14/适合入门的轻小说作品推荐/","date":"06-14","excerpt":"","tags":[{"name":"轻小说","slug":"轻小说","permalink":"https://hcl411x.github.io/tags/轻小说/"}],"preview":"imgs\\blog\\1.jpg"}]}